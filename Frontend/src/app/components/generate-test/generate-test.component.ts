
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { TestService } from '../../services/test.service';
import { QuestionService } from '../../services/question-service.service';
import { PublishTestComponent } from '../../components/adminCreatetest/publish-test/publish-test.component';
import { NgbModal, NgbModalModule } from '@ng-bootstrap/ng-bootstrap';
import { Router } from '@angular/router'; // <-- en haut

import { TestGenerationRequest } from '../../models/TestGenerationRequest ';
import { FormsModule } from '@angular/forms';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-generate-test',
  imports: [CommonModule, FormsModule, NgbModalModule
  ],
  templateUrl: './generate-test.component.html',
  styleUrl: './generate-test.component.css',
  standalone: true,
})
export class GenerateTestComponent {
  request: TestGenerationRequest = {
    titre: '',
    description: '',
    duree: 10,
    nbQuestions: 10,
    niveauDifficulte: 'MOYEN',
    type: 'QCM',
    accesPublic: true,
    limiteTentatives: 1,
    dateExpiration: new Date(),
    technologies: [],
    nbQcmFacile: 0,
    nbQcmMoyen: 0,
    nbQcmDifficile: 0,
    nbCodeFacile: 0,
    nbCodeMoyen: 0,
    nbCodeDifficile: 0,
    nbTexteFacile: 0,
    nbTexteMoyen: 0,
    nbTexteDifficile: 0,
    pointsParQuestion: 5,
  };

  techOptions = ['C', 'C++', 'Java', 'Python', 'JavaScript', 'TypeScript',
    'PHP', 'SQL', 'Kotlin', 'React.js', 'Vue.js', 'Angular', 'HTML', 'CSS'];
  questionsPreview: any[] = [];
  selectedTech: string[] = [];

  toggleTech(tech: string, event: any) {
    if (event.target.checked) this.request.technologies.push(tech);
    else this.request.technologies = this.request.technologies.filter(t => t !== tech);
  }
  token = localStorage.getItem('accessToken') ?? '';
  testId: number | null = null;
  constructor(private testService: TestService, private questionService: QuestionService, private modalService: NgbModal, private router: Router
  ) { }
  // openPublishTestModal() {
  //   const modalRef = this.modalService.open(PublishTestComponent); // Ouvre la modal
  //   modalRef.componentInstance.testId = this.testId;  // Passe l'ID du test √† la modal si n√©cessaire
  //   modalRef.componentInstance.testPublished.subscribe(() => this.onTestPublished()); // Abonnement √† l'√©v√©nement de publication
  // }
  openPublishTestModal() {
    const modalRef = this.modalService.open(PublishTestComponent); // Open the modal
    modalRef.componentInstance.testId = this.testId;  // Pass the test ID to the modal if necessary
    modalRef.componentInstance.testPublished.subscribe(() => {
      this.onTestPublished();  // Handle test publication logic
      modalRef.close();        // Close the modal after the test is published
    });
  }


  // Ajout de logs dans la fonction generateTest
  // validateForm() {
  //   // V√©rification du titre
  //   if (!this.request.titre.trim()) {
  //     alert('Titre est obligatoire.');
  //     return false;
  //   }

  //   // V√©rification de la dur√©e (doit √™tre sup√©rieur √† 0)
  //   if (this.request.duree <= 0) {
  //     alert('La dur√©e doit √™tre sup√©rieure √† 0.');
  //     return false;
  //   }

  //   // V√©rification du nombre total de questions (doit √™tre sup√©rieur √† 0)
  //   if (this.request.nbQuestions <= 0) {
  //     alert('Le nombre total de questions doit √™tre sup√©rieur √† 0.');
  //     return false;
  //   }

  //   // V√©rification de la s√©lection du type de test
  //   if (!this.request.type) {
  //     alert('Veuillez s√©lectionner un type de test.');
  //     return false;
  //   }
  //   this.request.technologies = [...this.selectedTech];

  //   // V√©rification des technologies s√©lectionn√©es
  //   if (this.request.technologies.length === 0) {
  //     alert('Veuillez s√©lectionner au moins une technologie.');
  //     return false;
  //   }

  //   // Validation sp√©cifique aux types de test pour les questions
  //   if (this.request.type === 'QCM' || this.request.type === 'Mixte') {
  //     if (this.request.nbQcmFacile <= 0 && this.request.nbQcmMoyen <= 0 && this.request.nbQcmDifficile <= 0) {
  //       alert('Vous devez d√©finir au moins une question QCM.');
  //       return false;
  //     }
  //   }

  //   if (this.request.type === 'Code' || this.request.type === 'Mixte') {
  //     if (this.request.nbCodeFacile <= 0 && this.request.nbCodeMoyen <= 0 && this.request.nbCodeDifficile <= 0) {
  //       alert('Vous devez d√©finir au moins une question de code.');
  //       return false;
  //     }
  //   }

  //   if (this.request.type === 'text' || this.request.type === 'Mixte') {
  //     if (this.request.nbTexteFacile <= 0 && this.request.nbTexteMoyen <= 0 && this.request.nbTexteDifficile <= 0) {
  //       alert('Vous devez d√©finir au moins une question texte.');
  //       return false;
  //     }
  //   }

  //   return true; // Si tout est valide
  // }
  validateForm() {
    // V√©rification du titre
    if (!this.request.titre.trim()) {
      Swal.fire('Champ requis', 'Le titre est obligatoire.', 'warning');
      return false;
    }

    // V√©rification de la dur√©e
    if (this.request.duree <= 0) {
      Swal.fire('Dur√©e invalide', 'La dur√©e doit √™tre sup√©rieure √† 0.', 'warning');
      return false;
    }

    // V√©rification du nombre total de questions
    if (this.request.nbQuestions <= 0) {
      Swal.fire('Nombre de questions requis', 'Le nombre total de questions doit √™tre sup√©rieur √† 0.', 'warning');
      return false;
    }

    // V√©rification du type de test
    if (!this.request.type) {
      Swal.fire('Type de test', 'Veuillez s√©lectionner un type de test.', 'warning');
      return false;
    }

    // Affecter les technologies s√©lectionn√©es
    this.request.technologies = [...this.selectedTech];

    // V√©rification des technologies
    if (this.request.technologies.length === 0) {
      Swal.fire('Technologies manquantes', 'Veuillez s√©lectionner au moins une technologie.', 'warning');
      return false;
    }

    // V√©rification des questions QCM
    if (this.request.type === 'QCM' || this.request.type === 'Mixte') {
      if (
        this.request.nbQcmFacile <= 0 &&
        this.request.nbQcmMoyen <= 0 &&
        this.request.nbQcmDifficile <= 0
      ) {
        Swal.fire('Questions QCM', 'Vous devez d√©finir au moins une question QCM.', 'warning');
        return false;
      }
    }

    // V√©rification des questions de code
    if (this.request.type === 'Code' || this.request.type === 'Mixte') {
      if (
        this.request.nbCodeFacile <= 0 &&
        this.request.nbCodeMoyen <= 0 &&
        this.request.nbCodeDifficile <= 0
      ) {
        Swal.fire('Questions Code', 'Vous devez d√©finir au moins une question de code.', 'warning');
        return false;
      }
    }

    // V√©rification des questions texte
    if (this.request.type === 'text' || this.request.type === 'Mixte') {
      if (
        this.request.nbTexteFacile <= 0 &&
        this.request.nbTexteMoyen <= 0 &&
        this.request.nbTexteDifficile <= 0
      ) {
        Swal.fire('Questions Texte', 'Vous devez d√©finir au moins une question texte.', 'warning');
        return false;
      }
    }

    // ‚úÖ Tout est bon
    return true;
  }
  generateQuestionsPreview() {
    if (!this.validateForm()) {
      return;
    }

    const token = localStorage.getItem('accessToken');
    if (!token) {
      Swal.fire({
        icon: 'error',
        title: 'Token manquant',
        text: 'üö´ Veuillez vous reconnecter.',
      });
      return;
    }

    this.request.technologies = [...this.selectedTech];
    const requestData = this.request;

    console.log('üì§ Donn√©es envoy√©es pour g√©n√©rer les questions:', requestData);

    Swal.fire({
      title: 'G√©n√©ration des questions...',
      text: 'Veuillez patienter...',
      allowOutsideClick: false,
      didOpen: () => {
        Swal.showLoading();
      }
    });

    this.testService.generateQuestions(requestData, token).subscribe({
      next: (response) => {
        this.questionsPreview = response.questions;
        console.log('‚úÖ Questions g√©n√©r√©es:', response.questions);
        console.log('‚ÑπÔ∏è Message:', response.message);

        // Cr√©er ensuite le test
        const testToSend = {
          titre: requestData.titre,
          description: requestData.description,
          duree: requestData.duree,
          nbQuestions: requestData.nbQuestions,
          niveauDifficulte: requestData.niveauDifficulte,
          type: requestData.type,
          technologies: requestData.technologies,
        };

        this.testService.createTest(testToSend, token).subscribe({
          next: (response) => {
            this.testId = response.id;
            console.log('üìù Test cr√©√© avec succ√®s:', response);

            Swal.fire({
              icon: 'success',
              title: 'Test cr√©√© avec succ√®s üéâ',
              text: 'Les questions ont √©t√© g√©n√©r√©es et le test a √©t√© enregistr√©.',
            });
          },
          error: (err) => {
            console.error('‚ùå Erreur lors de la cr√©ation du test:', err);
            Swal.fire({
              icon: 'error',
              title: 'Erreur lors de la cr√©ation du test',
              text: err.error?.message || 'Une erreur est survenue lors de l\'enregistrement.',
            });
          }
        });
      },
      error: (err) => {
        console.error('‚ùå Erreur lors de la g√©n√©ration des questions:', err);
        const errorMessage = err.error?.error || 'Erreur inconnue lors de la g√©n√©ration';

        Swal.fire({
          icon: 'error',
          title: 'Erreur lors de la g√©n√©ration des questions',
          text: '‚ùå ' + errorMessage,
        });
      }
    });
  }


  // generateQuestionsPreview() {
  //   if (!this.validateForm()) {
  //     return;
  //   }

  //   const token = localStorage.getItem('accessToken');
  //   if (!token) return alert('üö´ Token manquant');

  //   this.request.technologies = [...this.selectedTech];

  //   console.log('üì§ Donn√©es envoy√©es pour g√©n√©rer les questions:', this.request);

  //   const requestData = this.request;

  //   // 1. G√©n√©rer les questions en premier
  //   this.testService.generateQuestions(requestData, token).subscribe({
  //     next: (response) => {
  //       this.questionsPreview = response.questions;
  //       console.log('‚úÖ Questions g√©n√©r√©es:', response.questions);
  //       console.log('‚ÑπÔ∏è Message:', response.message);

  //       // 2. Une fois les questions g√©n√©r√©es, cr√©er le test
  //       const testToSend = {
  //         titre: requestData.titre,
  //         description: requestData.description,
  //         duree: requestData.duree,
  //         nbQuestions: requestData.nbQuestions,
  //         niveauDifficulte: requestData.niveauDifficulte,
  //         type: requestData.type,
  //         technologies: requestData.technologies,
  //       };

  //       this.testService.createTest(testToSend, token).subscribe({
  //         next: (response) => {
  //           this.testId = response.id;
  //           console.log('üìù Test cr√©√© avec succ√®s:', response);
  //           alert('‚úÖ Test cr√©√© avec succ√®s apr√®s g√©n√©ration des questions !');
  //         },
  //         error: (err) => {
  //           console.error('‚ùå Erreur lors de la cr√©ation du test:', err);
  //           alert('‚ùå Erreur lors de la cr√©ation du test');
  //         }
  //       });
  //     },
  //     error: (err) => {
  //       console.error('‚ùå Erreur lors de la g√©n√©ration des questions:', err);
  //       const errorMessage = err.error?.error || 'Erreur inconnue lors de la g√©n√©ration';
  //       alert('‚ùå ' + errorMessage);
  //     }
  //   });
  // }


  // Ajout de logs dans la fonction generateQuestionsPreview
  // generateQuestionsPreview() {
  //   if (!this.validateForm()) {
  //     return;
  //   }
  //   const token = localStorage.getItem('accessToken');
  //   if (!token) return alert('üö´ Token manquant');
  //   this.request.technologies = [...this.selectedTech];

  //   // Affiche la valeur de la dur√©e avant l'envoi
  //   console.log('Dur√©e avant envoi pour preview des questions:', this.request.duree);
  //   console.log('technologie avant envoi pour preview des questions:', this.request.technologies);

  //   const requestData = this.request;

  //   // Affiche l'ensemble de la requ√™te avant l'envoi
  //   console.log('Donn√©es envoy√©es pour g√©n√©rer les questions:', requestData);
  //   const testToSend = {
  //     titre: requestData.titre,
  //     description: requestData.description,
  //     duree: requestData.duree,
  //     nbQuestions: requestData.nbQuestions,
  //     niveauDifficulte: requestData.niveauDifficulte,
  //     type: requestData.type,
  //     technologies: requestData.technologies,
  //   }
  //   // Affiche l'ensemble de la requ√™te avant l'envoi
  //   console.log('Donn√©es envoy√©es √† l\'API:', requestData);
  //   this.testService.createTest(testToSend, this.token).subscribe({
  //     next: (response) => {
  //       this.testId = response.id;
  //       console.log('Test cr√©√© avec succ√®s:', response);
  //       alert('Test cr√©√© avec succ√®s!');
  //     },
  //     error: (err) => {
  //       console.error('Erreur lors de la cr√©ation du test:', err);
  //       alert('Erreur lors de la cr√©ation du test');
  //     }
  //   });
  //   this.testService.generateQuestions(requestData, token).subscribe({
  //     next: (questions) => {
  //       this.questionsPreview = questions;
  //       console.log('Questions g√©n√©r√©es:', questions);
  //     },
  //     error: (err) => {
  //       console.error('Erreur lors de la g√©n√©ration des questions:', err);
  //       alert('‚ùå Erreur lors de la g√©n√©ration des questions');
  //     }
  //   });

  // }

  onTestPublished() {
    console.log('Publication du test...');

    setTimeout(() => {
      console.log('Test publi√© et emails envoy√©s!');

      // Maintenant, passer √† la derni√®re √©tape
    }, 2500); // Temps de chargement simul√©
  }
  regenerateQuestions() {
    const token = localStorage.getItem('accessToken');
    if (!token) return alert('üö´ Token manquant');

    this.request.technologies = [...this.selectedTech];

    console.log('üîÅ R√©g√©n√©ration des questions avec :', this.request);

    this.testService.generateQuestions(this.request, token).subscribe({
      next: (response) => {
        this.questionsPreview = response.questions;
        console.log('‚úÖ Questions r√©g√©n√©r√©es:', response.questions);
        console.log('‚ÑπÔ∏è Message:', response.message);
        Swal.fire('Succ√®s', '‚úîÔ∏è Les questions ont √©t√© r√©g√©n√©r√©es avec succ√®s.', 'success');
      },
      error: (err) => {
        console.error('‚ùå Erreur lors de la r√©g√©n√©ration des questions:', err);
        const errorMessage = err.error?.error || 'Erreur inconnue lors de la r√©g√©n√©ration';
        Swal.fire('Erreur', '‚ùå ' + errorMessage, 'error');
      }
    });
  }

  supprimerQuestion(index: number): void {
    this.questionsPreview.splice(index, 1);
  }

  remplacerQuestion(index: number): void {
    const questionARemplacer = this.questionsPreview[index];

    const request = {
      id: questionARemplacer.id,
      type: questionARemplacer.type,
      niveau: questionARemplacer.niveau,
      technologie: questionARemplacer.technologie
    };

    this.questionService.remplacerQuestion(request).subscribe({
      next: (nouvelleQuestion) => {
        this.questionsPreview[index] = nouvelleQuestion;
      },
      error: (err) => {
        alert("Impossible de remplacer la question : " + err.error.message);
      }
    });
  }
  validerTest(): void {
    const token = localStorage.getItem('accessToken');
    if (!token) return alert('üö´ Token manquant');

    if (!this.testId) {
      return alert('‚ùå Test non encore cr√©√©');
    }

    const questionsToAssign = this.questionsPreview.map((q, index) => ({
      question: { id: q.id },
      points: q.selectedPoints ?? this.request.pointsParQuestion,
      ordre: q.selectedOrdre ?? index + 1
    }));

    console.log('üîí Validation du test - Questions √† assigner:', questionsToAssign);

    this.testService.addQuestionsToTest(this.testId, questionsToAssign, token).subscribe({
      next: (response) => {
        console.log('‚úÖ Questions ajout√©es avec succ√®s :', response);
        alert('üéâ Test valid√© et questions assign√©es avec succ√®s!');
      },
      error: (error) => {
        console.error('‚ùå Erreur lors de l\'assignation des questions :', error);
        alert('Erreur lors de l\'assignation des questions au test.');
      }
    });
    this.openPublishTestModal();

  }
  annuler(): void {
    if (confirm('√ätes-vous s√ªr de vouloir annuler ? Le test en cours sera supprim√©.')) {
      this.testService.deleteTest(this.testId!, this.token).subscribe({
        next: () => {
          console.log('‚úÖ Test brouillon supprim√© avec succ√®s');
          alert('Test annul√© et supprim√© avec succ√®s.');
          this.router.navigate(['/admin/test-management']); // <-- ajuste si besoin
        }
      });
    }
  }
}
